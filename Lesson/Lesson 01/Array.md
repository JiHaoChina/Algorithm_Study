| 数组 |                                                              |
| ---- | :----------------------------------------------------------- |
|      |                                                              |
|      | 第一题： Leetcode88 合并两个有序数组                         |
|      |                                                              |
|      | 给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。 |
|      |                                                              |
|      | 初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。 |
|      |                                                              |
|      |                                                              |
|      | 主题思路：                                                   |
|      | i，j两个索引，谁小放谁；                                     |
|      | 首先题目，是两个有序数组 ； 并且第一个数组，已经开好总和大小的数组。 |
|      | 通过两个数组的索引，通过对两个数组从后向前，比较两个索引的数组,元素值大的从后向前，进行顺序存放到nums1，这样就不用新开数组。 |
|      | 细节要注意数组越界问题，当一个数组的索引值小于0的时候，要把另一个数组的值存到新数组。 |
|      |                                                              |
|      | 代码：                                                       |
|      |                                                              |
|      | `class Solution {`                                           |
|      | `public:`                                                    |
|      | `//归并排序`                                                 |
|      | `void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {` |
|      | `int i=m-1;`                                                 |
|      | `int j=n-1;`                                                 |
|      | `for(int k = m+n-1;k>=0;k--)`                                |
|      | `{`                                                          |
|      | `if(i<0 \|\|(j>=0 && nums2[j]>nums1[i]))`                    |
|      | `{`                                                          |
|      | `nums1[k] = nums2[j];`                                       |
|      | `j--;`                                                       |
|      |                                                              |
|      | `}`                                                          |
|      | `else`                                                       |
|      | `{`                                                          |
|      | `nums1[k]=nums1[i];`                                         |
|      | `i--;`                                                       |
|      |                                                              |
|      | `}`                                                          |
|      | `}`                                                          |
|      |                                                              |
|      | `}`                                                          |
|      | `};`                                                         |
|      | 这道题的算法是 归并排序的基本操作。                          |
|      |                                                              |
|      | 第二题： Leetcode26 去重                                     |
|      | 给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。 |
|      |                                                              |
|      | 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 |
|      |                                                              |
|      | 主体思路：                                                   |
|      | 根据题目，要求不要使用额外的数组空间，对于此题，也是使用两个索引，对数组进行遍历。 |
|      | 第一个索引，对数组从前向后进行存值，第二个索引，一直向后进行遍历。 |
|      |                                                              |
|      | 代码：                                                       |
|      | `class Solution {`                                           |
|      | `public:`                                                    |
|      | `int removeDuplicates(vector<int>& nums) {`                  |
|      | `int n = 0;`                                                 |
|      | `for(int i =0 ;i<nums.size();i++)`                           |
|      | `{`                                                          |
|      | `if(i == 0 \|\| nums[i]!=nums[i-1])`                         |
|      | `{`                                                          |
|      | `nums[n] = nums[i];`                                         |
|      | `n++;`                                                       |
|      | `}`                                                          |
|      | `}`                                                          |
|      | `return n;`                                                  |
|      | `}`                                                          |
|      | `};`                                                         |
|      |                                                              |
|      | 第三题: Leetcode 283 移动零                                  |
|      | 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 |
|      |                                                              |
|      | 主题思路：                                                   |
|      | 题目和上题类似。通过两个索引，对数组进行操作。用一个索引，存放不等于0的数值；另一个索引，用来向后遍历数组。 |
|      |                                                              |
|      | 代码：                                                       |
|      | `class Solution {`                                           |
|      | `public:`                                                    |
|      | `void moveZeroes(vector<int>& nums) {`                       |
|      | `int n = 0;`                                                 |
|      |                                                              |
|      | `for(int i =0;i<nums.size();i++)`                            |
|      | `if(nums[i]!=0) nums[n++] =nums[i];`                         |
|      |                                                              |
|      | `for(;n<len;n++)  nums[n] = 0;`                              |
|      | `}`                                                          |
|      | `};`                                                         |